package org.sarge.textrpg.contents;

import static org.sarge.lib.util.Check.notNull;

import java.util.stream.Stream;

import org.sarge.textrpg.common.CommandArgument;
import org.sarge.textrpg.common.Damage;
import org.sarge.textrpg.common.Emission;
import org.sarge.textrpg.common.Hidden;
import org.sarge.textrpg.common.Size;
import org.sarge.textrpg.util.Description;
import org.sarge.textrpg.util.Percentile;

/**
 * A <i>thing</i> is an object or entity that can belong to a set of {@link Contents}.
 * @see Parent
 * @author Sarge
 */
public abstract class Thing implements Hidden, CommandArgument {
	private Parent parent = Parent.LIMBO;

	/**
	 * @return Name of this thing
	 */
	@Override
	public abstract String name();

	/**
	 * @return Weight of this thing (default is <tt>zero</tt>)
	 */
	public int weight() {
		return 0;
	}

	/**
	 * @return Size of this thing (default is {@link Size#NONE})
	 */
	public Size size() {
		return Size.NONE;
	}

	@Override
	public Percentile visibility() {
		return Percentile.ONE;
	}

	/**
	 * @param emission Type of emission
	 * @return Emission intensity generated by this thing
	 */
	public Percentile emission(Emission emission) {
		return Percentile.ZERO;
	}

	/**
	 * Helper - Finds the maximum strength of the given type of emission from a list of things.
	 * @param emission		Type of emission
	 * @param things 		Things
	 * @return Maximum strength of the given type of emission
	 */
	public static Percentile max(Emission emission, Stream<? extends Thing> things) {
		Percentile max = Percentile.ZERO;
		final var itr = things.iterator();
		while(itr.hasNext()) {
			final Percentile p = itr.next().emission(emission);
			if(Percentile.ONE.equals(max)) return Percentile.ONE;
			max = max.max(p);
		}
		return max;
	}

	/**
	 * @return Whether this thing is alive
	 */
	public boolean isAlive() {
		return parent != Parent.LIMBO;
	}

	/**
	 * Applies damage to this thing.
	 * @param type			Damage type
	 * @param amount		Amount of damage
	 */
	protected void damage(Damage.Type type, int amount) {
		throw new UnsupportedOperationException();
	}

	/**
	 * @return Whether this thing is omitted from location descriptions (default is <tt>false</tt>)
	 */
	public boolean isQuiet() {
		return false;
	}

	/**
	 * Raises a state-change notification for this thing and propagates it to its ancestor(s).
	 * @param notification Notification
	 * @see Parent#notify(ContentStateChange)
	 */
	public void raise(ContentStateChange notification) {
		// Skip if no parent
		if(parent == Parent.LIMBO) return;

		// Propagate to ancestors
		Parent p = parent;
		while(true) {
			// Re-calculate weight of parent
			if(notification.type() == ContentStateChange.Type.CONTENTS) {
				parent.contents().update();
			}

			// Notify parent, stop if terminated
			final boolean propagate = p.notify(notification);
			if(!propagate) break;

			// Otherwise walk to ancestor, stop at root
			p = p.parent();
			if(p == null) break;
		}
	}

	/**
	 * @return Description of this thing
	 * @throws UnsupportedOperationException by default
	 */
	public Description describe() {
		throw new UnsupportedOperationException();
	}

	/**
	 * @return Parent contents of this thing.
	 * @see Parent#LIMBO
	 */
	public Parent parent() {
		return parent;
	}

	/**
	 * Sets the parent of this thing.
	 * @param parent New parent
	 * @throws IllegalArgumentException if the given value is <tt>null</tt>, is already the parent of this thing, or is {@link Parent#LIMBO}
	 * @see Contents#add(Thing)
	 */
	public void parent(Parent parent) {
		notNull(parent);
		if(parent == this.parent) throw new IllegalArgumentException("Duplicate parent: " + this);
		if(parent == Parent.LIMBO) throw new IllegalArgumentException("Cannot explicitly move an object to limbo: " + this);
		parent.contents().add(this);
		remove();
		this.parent = parent;
	}

	/**
	 * Destroys this thing and removes it from the world.
	 * @throws IllegalStateException if this object has not been added to the world or has already been destroyed
	 */
	protected void destroy() {
		if(parent == Parent.LIMBO) throw new IllegalStateException("Cannot destroy an object that is already in limbo: " + this);
		remove();
		parent = Parent.LIMBO;
	}

	/**
	 * Helper - Removes this thing from its parent.
	 */
	private void remove() {
		parent.contents().remove(this);
	}

	@Override
	public String toString() {
		return name();
	}
}
